{"ast":null,"code":"import _classCallCheck from \"/home/constantin/workspace/vd-m-a-dummy/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/constantin/workspace/vd-m-a-dummy/node_modules/@babel/runtime/helpers/esm/createClass\";\nexport var Route = /*#__PURE__*/(function () {\n  var Route = /*#__PURE__*/function () {\n    function Route() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      _classCallCheck(this, Route);\n\n      this.nodes = [];\n      this.edges = [];\n      this.routeID = Route.count;\n      Route.count++;\n\n      if (name === null) {\n        this.name = 'Route ' + this.routeID;\n      } else {\n        this.name = name;\n      }\n    }\n\n    _createClass(Route, [{\n      key: \"getNodeByID\",\n      value: function getNodeByID(nodeId) {\n        return this.nodes.filter(function (node) {\n          return node.nodeId === nodeId;\n        })[0];\n      }\n    }, {\n      key: \"getEdgeByID\",\n      value: function getEdgeByID(edgeId) {\n        return this.edges.filter(function (edge) {\n          return edge.edgeId === edgeId;\n        })[0];\n      }\n    }, {\n      key: \"getStartNodeByEdgeID\",\n      value: function getStartNodeByEdgeID(edgeId) {\n        var edge = this.getEdgeByID(edgeId);\n        var node = this.getNodeByID(edge.startNode);\n        return node;\n      }\n    }, {\n      key: \"getEndNodeByEdgeID\",\n      value: function getEndNodeByEdgeID(edgeId) {\n        var edge = this.getEdgeByID(edgeId);\n        var node = this.getNodeByID(edge.endNode);\n        return node;\n      }\n    }, {\n      key: \"getEdgeByStartNodeID\",\n      value: function getEdgeByStartNodeID(nodeId) {\n        return this.edges.find(function (e) {\n          return e.startNode === nodeId;\n        });\n      }\n    }, {\n      key: \"setFtfBaseTopic\",\n      value: function setFtfBaseTopic(ftf) {\n        this.assignedFtfBaseTopic = ftf.getBaseTopic();\n      }\n    }, {\n      key: \"getFtfBaseTopic\",\n      value: function getFtfBaseTopic() {\n        return this.assignedFtfBaseTopic;\n      }\n    }, {\n      key: \"sortNodesAndEdgesFromStartToEnd\",\n      value: function sortNodesAndEdgesFromStartToEnd() {\n        // method returns true if there is a graph between start and end, otherwise false.\n        var sortedNodeList = [];\n        var sortedEdgeList = [];\n        var startNode = this.nodes.find(function (n) {\n          return n.start;\n        });\n        var startEdge = this.edges.find(function (e) {\n          return e.startNode === startNode.nodeId;\n        });\n        sortedNodeList.push(startNode);\n        sortedEdgeList.push(startEdge);\n        var nextNode = this.getEndNodeByEdgeID(startEdge.edgeId);\n        var endNodeFound = false;\n        sortedNodeList.push(nextNode);\n        endNodeFound = nextNode.end;\n\n        while (!endNodeFound) {\n          var nextEdge = this.getEdgeByStartNodeID(nextNode.nodeId);\n          nextNode = this.getEndNodeByEdgeID(nextEdge.edgeId);\n\n          if (nextNode === undefined || nextEdge === undefined) {\n            return false;\n          }\n\n          sortedNodeList.push(nextNode);\n          sortedEdgeList.push(nextEdge);\n          endNodeFound = nextNode.end;\n        }\n\n        this.nodes = sortedNodeList;\n        this.edges = sortedEdgeList;\n        return true;\n      }\n    }]);\n\n    return Route;\n  }();\n\n  Route.count = 0;\n  return Route;\n})();","map":null,"metadata":{},"sourceType":"module"}